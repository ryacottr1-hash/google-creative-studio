# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import logging
from typing import Optional

from fastapi import Depends

from src.common.dto.pagination_response_dto import PaginationResponseDto
from src.users.dto.user_create_dto import UserCreateDto, UserUpdateRoleDto
from src.users.dto.user_search_dto import UserSearchDto
from src.users.repository.user_repository import UserRepository
from src.users.user_model import UserModel, UserRoleEnum

logger = logging.getLogger(__name__)


class UserService:
    """
    Handles the business logic for user management.
    """

    def __init__(self, user_repo: UserRepository = Depends()):
        self.user_repo = user_repo

    async def create_user_if_not_exists(
        self, email: str, name: str, picture: Optional[str]
    ) -> UserModel:
        """
        Retrieves a user by their email. If the user exists, it returns it.
        If the user doesn't exist, it creates a new user document and a default workspace.
        """

        # 1. Check if the user already exists in the database.
        existing_user = await self.user_repo.get_by_email(email)

        if existing_user:
            return existing_user

        # 2. If the user does not exist, create a new User using UserCreateDto
        #    ID will be auto-generated by the DB
        new_user_dto = UserCreateDto(
            email=email,
            name=name,
            picture=picture or "",
        )

        # We need to ensure roles are set, but UserCreateDto doesn't have roles.
        # The repository create method takes a Pydantic model or dict.
        # If we pass UserCreateDto, we miss 'roles'.
        # We can pass a dict that includes roles.
        user_data = new_user_dto.model_dump()
        user_data["roles"] = [UserRoleEnum.USER]

        # 3. Call the repository's create() method
        new_user = await self.user_repo.create(user_data)

        # 4. Create a default workspace for the new user
        try:
            from src.workspaces.repository.workspace_repository import WorkspaceRepository
            from src.workspaces.schema.workspace_model import WorkspaceMember, WorkspaceModel, WorkspaceRoleEnum

            workspace_repo = WorkspaceRepository()

            # Create the user as the owner/first member of the workspace
            owner_as_member = WorkspaceMember(
                user_id=new_user.id,
                email=new_user.email,
                role=WorkspaceRoleEnum.OWNER
            )

            # Create the default workspace
            default_workspace = WorkspaceModel(
                name=f"{name}'s Workspace",
                owner_id=new_user.id,
            )

            await workspace_repo.create(default_workspace, initial_members=[owner_as_member])
            logger.info(f"Created default workspace for new user: {email}")
        except Exception as e:
            # Log the error but don't fail user creation if workspace creation fails
            logger.error(f"Failed to create default workspace for user {email}: {e}")

        return new_user

    async def get_user_by_id(self, user_id: int) -> Optional[UserModel]:
        """Finds a single user by their ID."""
        return await self.user_repo.get_by_id(user_id)

    async def find_all_users(
        self, search_dto: UserSearchDto
    ) -> PaginationResponseDto[UserModel]:
        """Retrieves a paginated list of all users."""
        return await self.user_repo.query(search_dto)

    async def update_user_role(
        self, user_id: int, role_data: UserUpdateRoleDto
    ) -> Optional[UserModel]:
        """Updates the role of a specific user."""
            
        # Convert the list of enums to a list of strings for DB
        roles_as_strings = [role.value for role in role_data.roles]

        # The update method in the repository would handle updating the 'role' field
        return await self.user_repo.update(user_id, {"roles": roles_as_strings})

    async def delete_user_by_id(self, user_id: int) -> bool:
        """Deletes a user from the system."""
        return await self.user_repo.delete(user_id)

